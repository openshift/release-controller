package bugzilla

import (
	"fmt"
	"regexp"
	"strings"
	"time"

	"k8s.io/klog"
	"k8s.io/kube-openapi/pkg/util/sets"
	"k8s.io/test-infra/prow/bugzilla"
	"k8s.io/test-infra/prow/github"
	"k8s.io/test-infra/prow/plugins"
)

// Verifier takes a list of bugzilla bugs and uses the Bugzilla client to
// retrieve the associated GitHub PR via the bugzilla bug's external bug links.
// It then uses the github client to read the comments of the associated PR to
// determine whether the bug's QA Contact reviewed the GitHub PR. If yes, the bug
// gets marked as VERIFIED in Bugzilla.
type Verifier struct {
	// bzClient is used to retrieve external bug links and mark QA reviewed bugs as VERIFIED
	bzClient bugzilla.Client
	// ghClient is used to retrieve comments on a bug's PR
	ghClient github.Client
	// pluginConfig is used to check whether a repository allows approving reviews as LGTM
	pluginConfig *plugins.Configuration
}

// NewVerifier returns a Verifier configured with the provided github and bugzilla clients and the provided pluginConfig
func NewVerifier(bzClient bugzilla.Client, ghClient github.Client, pluginConfig *plugins.Configuration) *Verifier {
	return &Verifier{
		bzClient:     bzClient,
		ghClient:     ghClient,
		pluginConfig: pluginConfig,
	}
}

// pr contains a bugzilla bug ID and the associated GitHub pr that resolves the bug
type pr struct {
	bugID int
	org   string
	repo  string
	prNum int
}

var (
	// bzAssignRegex matches the QA assignment comment made by the openshift-ci-robot
	bzAssignRegex = regexp.MustCompile(`Requesting review from QA contact:[[:space:]]+/cc @[[:alnum:]]+`)
	// from prow lgtm plugin
	lgtmRe       = regexp.MustCompile(`(?mi)^/lgtm(?: no-issue)?\s*$`)
	lgtmCancelRe = regexp.MustCompile(`(?mi)^/lgtm cancel\s*$`)
)

// VerifyBugs takes a list of bugzilla bug IDs and for each bug changes the bug status to VERIFIED if bug was reviewed and
// lgtm'd by the bug's QA Contect
func (c *Verifier) VerifyBugs(bugs []int) []error {
	bzPRs, errs := getPRs(bugs, c.bzClient)
	for _, bzp := range bzPRs {
		bug, err := c.bzClient.GetBug(bzp.bugID)
		if err != nil {
			errs = append(errs, fmt.Errorf("Unable to get bugzilla number %d: %v", bzp.bugID, err))
			continue
		}
		if bug.Status == "CLOSED" {
			continue
		}
		comments, err := c.ghClient.ListIssueComments(bzp.org, bzp.repo, bzp.prNum)
		if err != nil {
			errs = append(errs, fmt.Errorf("Unable to get comments for github pull %s/%s#%d: %v", bzp.org, bzp.repo, bzp.prNum, err))
			continue
		}
		reviews, err := c.ghClient.ListReviews(bzp.org, bzp.repo, bzp.prNum)
		if err != nil {
			errs = append(errs, fmt.Errorf("Unable to get reviews for github pull %s/%s#%d: %v", bzp.org, bzp.repo, bzp.prNum, err))
			continue
		}
		approved := prReviewedByQA(comments, reviews, c.pluginConfig.LgtmFor(bzp.org, bzp.repo).ReviewActsAsLgtm)
		if approved {
			klog.V(4).Infof("Updating bug %d (current status %s) to VERIFIED status", bug.ID, bug.Status)
			if err := c.bzClient.UpdateBug(bug.ID, bugzilla.BugUpdate{Status: "VERIFIED"}); err != nil {
				errs = append(errs, fmt.Errorf("Failed to update status for bug %d: %v", bug.ID, err))
			}
		} else {
			klog.V(4).Infof("Bug %d (current status %s) not approved by QA contact", bug.ID, bug.Status)
		}
	}
	return errs
}

// getPRs identifies bugzilla bugs and the associated github PRs fixed in a release from
// a given buglist generated by `oc adm release info --bugs=git-cache-path --ouptut=name from-tag to-tag`
func getPRs(input []int, bzClient bugzilla.Client) ([]pr, []error) {
	var bzPRs []pr
	var errs []error
	for _, bzID := range input {
		extBugs, err := bzClient.GetExternalBugPRsOnBug(bzID)
		if err != nil {
			// there are a couple of bugs with weird permissions issues that can cause this to fail; simply log instead of generating error
			if bugzilla.IsAccessDenied(err) {
				klog.V(4).Infof("Access denied getting external bugs for bugzilla bug %d: %v", bzID, err)
			} else {
				errs = append(errs, fmt.Errorf("Failed to get external bugs for bugzilla bug %d: %v", bzID, err))
			}
			continue
		}
		foundPR := false
		for _, extBug := range extBugs {
			if extBug.Type.URL == "https://github.com/" {
				bzPRs = append(bzPRs, pr{
					bugID: bzID,
					org:   extBug.Org,
					repo:  extBug.Repo,
					prNum: extBug.Num,
				})
				foundPR = true
				break
			}
		}
		if !foundPR {
			// sometimes people ignore the bot and manually change the bugzilla tags, resulting in a bug not being linked; ignore these
			klog.V(5).Infof("Failed to identify associated GitHub PR for bugzilla bug %d", bzID)
		}
	}
	return bzPRs, errs
}

func updateLGTMs(lgtms map[string]time.Time, lgtmCancels map[string]time.Time, body, login string, submitted time.Time) {
	if lgtmRe.MatchString(body) {
		lgtms[login] = submitted
		return
	}
	if lgtmCancelRe.MatchString(body) {
		lgtmCancels[login] = submitted
		return
	}
}

// prReviewedByQA looks through PR comments and identifies if an assigned
// QA contact lgtm'd the PR
func prReviewedByQA(comments []github.IssueComment, reviews []github.Review, reviewAsLGTM bool) bool {
	lgtms := make(map[string]time.Time)
	lgtmCancels := make(map[string]time.Time)
	qaContacts := sets.NewString()
	for _, comment := range comments {
		updateLGTMs(lgtms, lgtmCancels, comment.Body, comment.User.Login, comment.UpdatedAt)
		bz := bzAssignRegex.FindString(comment.Body)
		if bz != "" {
			splitbz := strings.Split(bz, "@")
			if len(splitbz) == 2 {
				qaContacts.Insert(splitbz[1])
			}
		}
	}
	for _, review := range reviews {
		updateLGTMs(lgtms, lgtmCancels, review.Body, review.User.Login, review.SubmittedAt)
		if reviewAsLGTM {
			if review.State == github.ReviewStateApproved {
				lgtms[review.User.Login] = review.SubmittedAt
				continue
			}
			if review.State == github.ReviewStateChangesRequested {
				lgtmCancels[review.User.Login] = review.SubmittedAt
				continue
			}
		}
	}
	finalLGTMs := sets.NewString()
	for user, lgtmTime := range lgtms {
		if cancelTime, ok := lgtmCancels[user]; ok {
			if cancelTime.After(lgtmTime) {
				continue
			}
		}
		finalLGTMs.Insert(user)
	}
	for contact := range qaContacts {
		for lgtm := range finalLGTMs {
			if contact == lgtm {
				klog.V(4).Infof("QA Contact %s lgtm'd this PR", contact)
				return true
			}
		}
	}
	return false
}
